# -*- coding: utf-8 -*-
"""Reto_Medicom_EDA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pS7h0CYnfBWs2hw14TTegid5RuN-FMtb
"""

# Loading the Data
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mt
from datetime import datetime
from sklearn.ensemble import RandomForestRegressor
from numpy.linalg import eig, inv
def data_cleaning():
  """
  Performs data cleanning. Maniupulating dates easily. 
  Introduces a variable "month_n_sales" which represents the sold ammount in month n (month n reffers to months passed after the first month recorded.)
  returns two dataframes, clients_df and product_df where data about both clients and products are stored, respectively.
  """
    
  df = pd.read_parquet('24o_medicom.parquet')
  """
  df

  df.info()

  df.describe()

  type(df.ventas)
  """
  df['ventas'] = df['ventas'].apply(int)

  #df.describe()

  # What about the dates?
  df['fecha'] = pd.to_datetime(df['fecha'])

  """
  plt.scatter(df.fecha, df.ventas)
  plt.title('Sales')
  plt.show()
  """

  """Yup, here we can see the gap. So, again we will only take dates after the gap, which occurs after 2020."""

  df = df[df['fecha'] >= '2020-01-01']

  df.reset_index(drop=True, inplace=True)
  #df

  df.sort_values(by='fecha', inplace=True)
  df.reset_index(drop=True, inplace=True)
  #df

  # For easier date manipulation we will use library dateutil

  from dateutil import relativedelta

  #df.fecha[0]

  # A month column will be added to have an idea of how many months have transcured since the first sale (after the gap).
  month_0 = df.fecha[0]

  for i in range(len(df)):
    diff = relativedelta.relativedelta(df.fecha[i], month_0)
    months_since = diff.years * 12 + diff.months
    df.loc[i, 'month'] = months_since

  #df

  """Now I will create a product dataframe where each row is a product, columns will be ID, month 1 sales, month 2 sales, ..., month 43 sales."""

  products = []

  # Get a list of unique product IDs
  product_ids = df['id_material'].unique()

  # Iterate over each product ID
  for product_id in product_ids:
    # Filter the DataFrame for the current product
    temp = df[df['id_material'] == product_id]

    # Create a dictionary to store sales data for the current product
    sales = {'id_material': product_id}

    # Iterate over the months and add sales data to the dictionary
    for month in range(44):
      if month in temp['month'].values:
        sales[f'month_{month}'] = temp[temp['month'] == month]['ventas'].sum()
      else:
        sales[f'month_{month}'] = 0

    # Create a DataFrame for the current product and append it to the list
    products.append(pd.DataFrame(sales, index=[0]))

  # Concatenate all product DataFrames into a single DataFrame
  product_df = pd.concat(products, ignore_index=True)

  #product_df

  # Cool. We will do the same now but for clients.
  clients = []

  # Get a list of unique product IDs
  clients_ids = df['id_cliente'].unique()

  # Iterate over each product ID
  for client_id in clients_ids:
    # Filter the DataFrame for the current product
    temp = df[df['id_cliente'] == client_id]

    # Create a dictionary to store sales data for the current product
    sales = {'id_cliente': client_id}

    # Iterate over the months and add sales data to the dictionary
    for month in range(44):
      if month in temp['month'].values:
        sales[f'month_{month}'] = temp[temp['month'] == month]['ventas'].sum()
      else:
        sales[f'month_{month}'] = 0

    # Create a DataFrame for the current product and append it to the list
    clients.append(pd.DataFrame(sales, index=[0]))

  # Concatenate all product DataFrames into a single DataFrame
  clients_df = pd.concat(clients, ignore_index=True)

  #clients_df

  clients_df.rename(columns={'id_cliente': 'ID'}, inplace=True)
  product_df.rename(columns={'id_material': 'ID'}, inplace=True)
  
  return df, clients_df, product_df

df, clients_df, product_df = data_cleaning()

# For latter purposes, we will merge both clients and prod ID's into one list. 
IDs = clients_df.ID.tolist() + product_df.ID.tolist()

"""How can we estimate the transition matrix?"""

# Perfect, so now that we have that, lets clarify the criteria we will be using to determine which products are deactivated and which ones are reactivated.
# Information was given in a zoom meeting with the clients, they suggest we choose a products based on how their monthly sales are performing, if their sales have been
# 0 or negative (sales <= 0) for more than 2 straight months, then the product becomes deactivated, but if it then has sales in another month, we can considered as reactivated.

# So, how we gonna approach this? For starters, note that a product can be in two states: deactivated and reactivated; yet, in between months: month n and month n+1, a product may
# or may not change its state, so we have 4 possible scenarios: [in a timelapse of 1] product i went from state A to state A (stayed deactivated) | product i went from state A to
# state B (Became reactivated) | product i went form state B to state A (Became deactivated) | product i went form state B to state B (stayed reactivated).

# If we now take a closer look, this means we gonna have a transition matrix in time lapse n = 0, which will include the prior probabilities of a product evolving states.
# We gonna get those.

# First we will get pi_0, the initial probabilities of being in one state or another.
"""
pi_0 = np.zeros(2)

pi_0[0] = len(product_df[product_df['month_0'] <= 0]) / len(product_df)
pi_0[1] = len(product_df[product_df['month_0'] > 0]) / len(product_df)

pi_0

products_p = np.zeros((2,2)) # Only 4 possible states.

# We will count proportions of how many products changed states.
products_p[0][0] = len(product_df[(product_df['month_0'] <= 0) & (product_df['month_1'] <= 0)]) / len(product_df[(product_df['month_0'] <= 0)])
products_p[0][1] = len(product_df[(product_df['month_0'] <= 0) & (product_df['month_1'] > 0)]) / len(product_df[(product_df['month_0'] <= 0)])
products_p[1][0] = len(product_df[(product_df['month_0'] > 0) & (product_df['month_1'] <= 0)]) / len(product_df[(product_df['month_0'] > 0)])
products_p[1][1] = len(product_df[(product_df['month_0'] > 0) & (product_df['month_1'] > 0)]) / len(product_df[(product_df['month_0'] > 0)])

products_p

What asumptions did you make?

# For simplicity purposes, although this is an estimated transision matrix, we can work with it for an ergodic markov chain.
# Why? Well, we first need to make some asumptions, we are assuming all products can either become reactivated or deactivated at any month; we are also asuming that both states
# have a period of 1: meaning the GREATEST COMMON DIVISOR between the number of months that need to pass for a product to return to any state is 1; finally, we are assuming
# both states are positively recurrent, meaning the average number of months it takes a product to adopt a certain state for the first time is finite.

# This is what we need to ensure the chain will converge... When? Well, that's the catch... Will it converge in a reasonable time lapse?

We can perform a little pdiction to see how far our model can predict.
We know a $2*2$ transition matrix $P$ has a formula for $P^{(n)} = VG^{n}V^{-1}$ where V is the eigen value matrix for P and G is a diagonal matrix with the eigenvalues for P.

"""

def P_n(P, n): # Probability of p in time n
    eigenvalues, eigenvectors = eig(P)
    G_n = np.diag(eigenvalues ** n)
    V_inv = inv(eigenvectors)
    P_n = eigenvectors @ G_n @ V_inv

    return P_n

"""
p_2 = P_n(products_p, 2)

p_2

# Lets now compare with the estimated transition matrix for month 2.
products_p2 = np.zeros((2,2))

products_p2[0][0] = len(product_df[(product_df['month_1'] <= 0) & (product_df['month_2'] <= 0)]) / len(product_df[(product_df['month_1'] <= 0)])
products_p2[0][1] = len(product_df[(product_df['month_1'] <= 0) & (product_df['month_2'] > 0)]) / len(product_df[(product_df['month_1'] <= 0)])
products_p2[1][0] = len(product_df[(product_df['month_1'] > 0) & (product_df['month_2'] <= 0)]) / len(product_df[(product_df['month_1'] > 0)])
products_p2[1][1] = len(product_df[(product_df['month_1'] > 0) & (product_df['month_2'] > 0)]) / len(product_df[(product_df['month_1'] > 0)])

products_p2

# We gonna plot this to see better.
states = ['P00', 'P01', 'P10', 'P11']

p2_values = [products_p2[0, 0], products_p2[0, 1], products_p2[1, 0], products_p2[1, 1]]
p_2_values = [p_2[0, 0], p_2[0, 1], p_2[1, 0], p_2[1, 1]]

plt.bar(states, p2_values, width=0.4, label='products_p2', color = 'gray')

plt.vlines(states, 0, p_2_values, colors='black', linestyles= 'dashdot', label='p_2')

plt.xlabel('Matrix Elements')
plt.ylabel('Probability')
plt.title('Comparison of Transition Matrices')

plt.legend()
plt.show()

df.ventas.describe()
"""

"""
Now, this is not ideal at all. Why? Well, considering a single transition matrix for all products leads to biased estimations, note the variance of the sales is huge, therefore this model might not be ideal for estimating single product. This model is useful for knowing how many products are in 'danger' of shifting states, but it will not be useful for estimating if x product will be deactiavted or reactivated in n months.

How can we approach this for specific products? Firts proposal: Considering sales percentiles, we can make an accurate representation for products that share a similar sales, therefore, estimating 12 Markov chains sounds reasonable: 1 per 10th percentile, and 2 for outliers (both extremes). This could model the behaviour of different products according to their sales (asuming the amount of the sale transaction determines wether it is bought more frequently), making it more realistic.

The other approach we can take is to perform Markov Chains for each client: assuming each client might represent a different behaviour for the products they buy, therefore, the probability for a product to go from state i to state j relies fully on the client. (We can also link client lifetime value to this: the higher the probabilities of keeping products at a reactivation state means high lifetime client value).

There is a third approach, though. What if we could estimate a transition matrix both for any client and any product, meaning the input would be an ID, and based on that, the function would estimate both the transition matrix and the estationary distribution.

Which one is better?
"""

#product_df

#clients_df

#-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------#

# Create the function that would estimate the transition matrix for an ID and a mat/client type.
def P_matrix(ID, t, n):
  # Right, so first we will asume df can have values of 'mat' or 'cli'

  if ID not in IDs:
     return None
  
  else: 
    if t == 'mat':
      df = product_df
    elif t == 'cli':
      df = clients_df

    P00_count = 0
    P01_count = 0
    P10_count = 0
    P11_count = 0
    P0_count = 0
    P1_count = 0

    for i in range(1, n+1):
      actual = int(df.loc[df['ID'] == ID, f'month_{i}'].iloc[0])
      prev = int(df.loc[df['ID'] == ID, f'month_{i-1}'].iloc[0])

      if prev <= 0 and actual <= 0:
        P00_count += 1
        P0_count += 1
      elif prev <= 0 and actual > 0:
        P01_count += 1
        P0_count += 1
      elif prev > 0 and actual <= 0:
        P10_count += 1
        P1_count += 1
      elif prev > 0 and actual > 0:
        P11_count += 1
        P1_count += 1



    if P0_count == 0:
      P0_count = 1
    if P1_count == 0:
      P1_count = 1

    P = np.array([[P00_count/P0_count, P01_count/P0_count], [P10_count/P1_count, P11_count/P1_count]])
    return P

#ej = P_matrix(305, t = 'cli', n = 43)

"""Nice, now we have a function that can estimate the probability for either a client or a product. This is really useful, actually."""

#ej

#abs(ej[0][0] + ej[0][1])

"""Lets also remember that the transition matrix for a client would mean the probability of either buying or not buying (this includes returning) given that they bought or did not buy."""

# Now we will create a function called status that, given the output, can provide interpretation for the transition matrix (this is client oriented.)
def status(P):


  max_prob_0 = max([P[0][0], P[0][1]])
  max_prob_1 = max([P[1][0], P[1][1]])

  difference_0 = abs(P[0][0] - P[0][1])<0.19 # Great difference would be more than 0.2
  difference_1 = abs(P[1][0] - P[1][1])<0.19
  status_0 = 0
  status_1 = 0

  if difference_0: # Not much difference for either being deactivated or reactivated given that the product was deactivated.
    status_0 = 0

  elif max_prob_0 == P[0][0]: # Most probable for the material to keep deactivated.
    status_0 = 1

  elif max_prob_0 == P[0][1]: # Most probable for the material to become activated.
    status_0 = 2

  if difference_1: # Not much difference for either being deactivated or reactivated given that the product was deactivated.
    status_1 = 0

  elif max_prob_1 == P[1][0]: # Most probable for the material to become deactivated.
    status_1 = 1

  elif max_prob_1 == P[1][1]: # Most probable for the material to keep reactivated.
    status_1 = 2


  return status_0, status_1

#status(P_matrix(305, t = 'cli', n = 43))

def information(ID, t, n):
  P = P_matrix(ID, t, n)
  status_0, status_1 = status(P)

  description = ''
  recommendation = ''
  valor_cliente = ''

  if t == 'cli':
      if status_0 == 0:
          description = f'The client with ID = {ID} tends to have irregular purchasing behavior when they did not buy last month. In other words, there is no significant difference in the probability of buying or not buying based on their inactivity last month.'
      elif status_0 == 1:
          description = f'The client with ID = {ID} tends not to buy regularly when they did not purchase last month. That is, it is more likely that they will also not buy in the following month.'
      elif status_0 == 2:
          description = f'The client with ID = {ID} tends to buy regularly even if they did not purchase last month. This means they are more likely to buy in the upcoming month.'

      if status_1 == 0:
          description += f'\n On the other hand, if the client did buy last month, there is no significant difference in the probability of buying or not buying this month.'

      elif status_1 == 1:
          description += f'\n On the other hand, if the client bought last month, they are more likely not to buy this month.'

      elif status_1 == 2:
          description += f'\n On the other hand, if the client bought last month, they are more likely to buy again this month.'

  elif t == 'mat':
      if status_0 == 0:
          description = f'The product with ID = {ID} shows erratic sales behavior when it was not sold last month. That is, there is no significant difference in the probability of being sold or remaining unsold based on last month’s inactivity.'
      elif status_0 == 1:
          description = f'The product with ID = {ID} tends not to be sold if it was not sold in the previous month. In other words, if it was not sold last month, it is unlikely to be sold this month either.'
      elif status_0 == 2:
          description = f'The product with ID = {ID} tends to sell even if it was not sold last month. This suggests it is likely to be purchased in the next month despite previous inactivity.'

      if status_1 == 0:
          description += f'\n On the other hand, if the product was sold last month, there is no significant difference in the probability of it being sold or not this month.'

      elif status_1 == 1:
          description += f'\n On the other hand, if the product was sold last month, it is more likely not to be sold this month.'

      elif status_1 == 2:
          description += f'\n On the other hand, if the product was sold last month, it is more likely to be sold again this month.'

  # Right, so now I have several possible combinations of status that will determine my recommendation.
  # Let's bring scenarios to life and picture what possibilities we have.

  # First scenario includes not much difference in probabilities of being sold knowing the product was not selling and not much difference in being sold knowing the product did sell last month.

  if status_0 == 0 and status_1 == 0:
      if t == 'cli':
          recommendation += f'Since client {ID} has irregular purchasing behavior, it may be easier for them to buy on a longer-term basis rather than monthly.\n'
          recommendation += 'Consider implementing a service exchange program that encourages monthly purchases, such as offering an additional service in return for regular purchases.\n'
          recommendation += 'E.g., exchanging a certain amount of a product for a monthly service like training, pest control, medical check-ups, etc.\n'

          valor_cliente = 'Medium'
      elif t == 'mat':
          recommendation += f'Since product {ID} has irregular monthly sales behavior, its sales could be boosted through promotions or discounts on complementary products.\n'
          recommendation += f'For example, offering a discount on a related product when purchasing {ID} within the same month.\n'

  # Second scenario: No significant difference in probability of being sold when it was not selling, and it is more likely not to be sold even if it was sold last month.
  elif status_0 == 0 and status_1 == 1:
      if t == 'cli':
          recommendation += f'Since client {ID} has a low probability of continuing to buy after a monthly purchase, consider focusing on loyalty programs or discounts for repeat purchases to increase buying frequency.\n'
          recommendation += 'For example, offering exclusive discounts for consecutive purchases or a points program that rewards customer loyalty.\n'

          valor_cliente = 'Low'
      elif t == 'mat':
          recommendation += f'Since product {ID} has a low probability of being repurchased after a sale, consider strategies like marketing campaigns emphasizing its long-term value or introducing updated versions to maintain interest.\n'
          recommendation += 'You could also use a more aggressive promotional cycle after an initial sale to keep the product in customers’ minds.\n'

  # Third scenario: No significant difference in probability of being sold when it was not selling, and it is more likely to be sold if it was sold last month.
  elif status_0 == 0 and status_1 == 2:
      if t == 'cli':
          recommendation += f'Since client {ID} tends to continue purchasing after making an initial purchase, consider encouraging first-time purchases with introductory offers, knowing they are likely to buy again.\n'
          recommendation += 'Offer a discount on the first purchase or an attractive incentive to encourage the client to try the product, increasing the chance of repeat purchases.\n'

          valor_cliente = 'High'

      elif t == 'mat':
          recommendation += f'Since product {ID} has a high probability of continued sales after an initial purchase, consider strategies to encourage the first sale, such as first-time buyer discounts or free samples.\n'
          recommendation += 'This ensures that once the product is purchased, future sales probabilities remain high.\n'

  # Fourth scenario: High probability of being sold even if it wasn’t sold last month, but no significant difference in sales likelihood after previous sales.
  elif status_0 == 2 and status_1 == 0:
      if t == 'cli':
          recommendation += f'Client {ID} appears to have intermittent interest in monthly purchases. Consider personalized reminders or temporary promotions to keep them engaged.\n'
          recommendation += 'For example, sending emails with exclusive discounts at moments when interest seems to drop could help sustain engagement.\n'

          valor_cliente = 'High'
      elif t == 'mat':
          recommendation += f'Product {ID} has a chance of being sold even if it wasn’t sold last month, but future sales are inconsistent. Consider seasonal promotions or product bundles to increase sales regularity.\n'
          recommendation += 'A marketing strategy highlighting the product’s specific benefits could also help stabilize sales.\n'

  # Fifth scenario: High probability of being sold if it was not selling last month, but more likely not to be sold after previous sales.
  elif status_0 == 2 and status_1 == 1:
      if t == 'cli':
          recommendation += f'Since client {ID} tends to buy after a period of inactivity but does not continue purchasing, consider implementing post-purchase retention strategies.\n'
          recommendation += 'For example, a follow-up campaign offering a discount or special deal after an initial purchase could encourage future purchases.\n'

          valor_cliente = 'Low'
      elif t == 'mat':
          recommendation += f'Product {ID} has a high chance of being sold after a period without sales but does not remain in the purchase cycle. Consider offering deals or promotions exclusively for consecutive purchases.\n'
          recommendation += 'This could help stabilize sales and increase customer loyalty to the product.\n'

  # Sixth scenario: High probability of being sold whether or not it was selling last month.
  elif status_0 == 2 and status_1 == 2:
      if t == 'cli':
          recommendation += f'Since client {ID} shows a strong likelihood of repurchasing after both inactivity and previous purchases, consider maximizing this trend with robust loyalty programs.\n'
          recommendation += 'Offer incremental rewards for consecutive purchases or bigger discounts as the client buys regularly.\n'

          valor_cliente = 'Very High'
      elif t == 'mat':
          recommendation += f'Product {ID} has a high likelihood of sales both after inactivity and sustained activity. This suggests a strong product with steady demand.\n'
          recommendation += 'Maximize this strength by featuring the product in regular promotions and ensuring it is always in stock. Additionally, consider marketing campaigns reinforcing its exclusivity or quality to maintain high demand.\n'

  # Seventh scenario: Low probability of being sold after inactivity, but no significant difference in sales likelihood after previous sales.
  elif status_0 == 1 and status_1 == 0:
      if t == 'cli':
          recommendation += f'Since client {ID} shows a low probability of purchasing after inactivity, consider reactivation strategies with personalized offers.\n'
          recommendation += 'Send promotions aligned with their interests or explore new engagement methods, such as exclusive events or relevant content.\n'

          valor_cliente = 'Very Low'

      elif t == 'mat':
          recommendation += f'Product {ID} struggles to regain sales momentum after a period of inactivity. Consider repositioning it in the market or introducing improved versions to attract new buyers.\n'
          recommendation += 'Marketing campaigns highlighting product benefits or featuring customer testimonials could also help drive new sales.\n'

  # Eighth scenario: Low probability of being sold in all cases.
  elif status_0 == 1 and status_1 == 1:
      if t == 'cli':
          recommendation += f'Client {ID} is at risk of churn, as they show a low likelihood of purchasing both after inactivity and previous purchases.\n'
          recommendation += 'Consider reactivation strategies such as surveys to understand their disengagement, personalized offers, or incentives to bring them back.\n'
          recommendation += 'Another option is to explore new ways to provide value, such as improved customer service or complementary products.\n'

          valor_cliente = 'Very Low'
      elif t == 'mat':
          recommendation += f'Product {ID} has a high probability of not being sold regardless of past performance, suggesting it may be losing market relevance.\n'
          recommendation += 'Consider a full reassessment of the product strategy, including potential improvements, market repositioning, or even discontinuation if it is not viable.\n'
          recommendation += 'Alternatively, clearance sales or bundle deals with more successful products could help clear inventory.\n'

  # Ninth scenario: Low probability of being sold after inactivity, but high probability of being sold if it was selling last month.
  elif status_0 == 1 and status_1 == 2:
      if t == 'cli':
          recommendation += f'Client {ID} tends to buy once engaged but is difficult to reactivate after inactivity.\n'
          recommendation += 'Consider incentives for consecutive purchases or personalized reminders to prevent them from becoming inactive.\n'
          recommendation += 'This could include discounts for consecutive purchases or exclusive content to maintain engagement month after month.\n'

          valor_cliente = 'Medium'

      elif t == 'mat':
          recommendation += f'Product {ID} tends to sell once it is in the purchase cycle but struggles to regain sales after periods of inactivity.\n'
          recommendation += 'A strategy could be reactivation campaigns with special offers for customers who have not purchased in a while, ensuring the product remains in the sales cycle.\n'

  return description, recommendation, valor_cliente

#print(information(305, t = 'cli', n = 43)[1])

def prob_plot(ID, t):
  P = P_matrix(ID, t, 43)  # Compute probabilities

  prob_get_sold = [P[0][1]]
  prob_continue_sold = [P[1][1]]

  for i in range(2, 13):
    p_n = P_n(P, i)
    prob_get_sold.append(p_n[0][1])
    prob_continue_sold.append(p_n[1][1])

  months = [i for i in range(1, 13)]

  # Set up figure
  fig, ax = plt.subplots(figsize=(6, 4))
  fig.patch.set_facecolor('white')
  ax.set_facecolor('white')

  # Plot with monochrome + blue
  ax.plot(months, prob_get_sold, color='#4169E1', label=f'Prob {ID} buys', linewidth=2.5, linestyle='dashed')  # Black line
  ax.plot(months, prob_continue_sold, color='black', label=f'Prob {ID} keeps buying', linewidth=2.5, linestyle='solid')  # Royal Blue, dashed

  # Aesthetics
  ax.set_title(f'Probability {ID} Buys This Year', fontsize=14, fontweight='bold', color='black')
  ax.set_xlabel('Months', fontsize=12, color='black')
  ax.set_ylabel('Probability', fontsize=12, color='black')
  ax.legend(loc='upper right', fontsize=11, frameon=False)
  ax.grid(True, linestyle='--', linewidth=0.5, color='#CCCCCC')  # Subtle gray grid lines

  return fig

"""
clients_df

product_df

sales = clients_df.loc[clients_df['ID'] == 305].iloc[0,1:].values

plt.plot(sales, color='#0033A0', label=f'Modelo', linewidth=2)
plt.show()
"""

def predict_sales(t, ID, months_to_predict=2):
  """
  Predicts future sales for a given client/product.
  
  Parameters:
  t type of object, cli = client, prod = product. 
  client_id (int): ID of the client/product to predict.
  months_to_predict (int): Number of months to predict.
  
  Returns:
  np.array: Predicted sales for the next 'months_to_predict' months.
  """
  if t == 'cli':
    sales = clients_df.loc[clients_df['ID'] == ID].iloc[0,1:].values
  elif t == 'mat': 
    sales = product_df.loc[product_df['ID'] == ID].iloc[0,1:].values
  else: 
      return None
  
  # Prepare training data (X = months, y = sales)
  months = np.arange(len(sales)).reshape(-1, 1)
  
  # Dynamically create lag features
  def create_lags(arr, lags=2):
      X = []
      y = []
      for i in range(lags, len(arr)):  
          X.append(arr[i-lags:i])  # Past 'lags' months as features
          y.append(arr[i])  # Current sales as target
      return np.array(X), np.array(y)

  # Create lag features (without modifying df)
  X_train, y_train = create_lags(sales, lags=2)
  
  # Train Random Forest
  model = RandomForestRegressor(n_estimators=70, max_depth=10, min_samples_split=10, min_samples_leaf=5)
  model.fit(X_train, y_train)
  
  # Generate past predictions (out-of-sample) to check model generalization
  historical_predictions = []
  for i in range(2, len(sales)):  # Start from the 2nd month to ensure lag can be used
      historical_input = sales[i-2:i]
      historical_predictions.append(model.predict(historical_input.reshape(1, -1))[0])
  
  # Generate future predictions (for the next months_to_predict)
  last_known = sales[-2:]  # Last two sales as input
  future_predictions = []
  for _ in range(months_to_predict):
      pred = model.predict(last_known.reshape(1, -1))[0]  # Predict next sales
      future_predictions.append(pred)
      last_known = np.append(last_known[1:], pred)  # Shift window
  
  # Combine past predictions and future predictions
  combined_predictions = np.concatenate([historical_predictions, future_predictions])
  
  # Plotting
  fig, ax = plt.subplots(figsize=(6, 4))
  fig.patch.set_facecolor('white')
  ax.set_facecolor('white')

  # Plot real sales (blue) and combined predictions (orange)
  ax.plot(months, sales, color='#0033A0', label=f'Real sales of {ID}')
  ax.plot(np.arange(2, len(sales) + months_to_predict), combined_predictions, color='orange', label=f'Predicted sales of {ID}')

  ax.set_title(f'Estimated x Real for {ID}', fontsize=16, fontweight='bold', color='black')
  ax.set_xlabel('Month')
  ax.set_ylabel('Currency')
  ax.legend()
  
  return fig

"""
prob_plot(305, t = 'cli').show()

forecast(614, t = 'mat').show()

prob_plot(614, t = 'mat').show()

prob_plot(6953, t = 'mat').show()

P_matrix(6953, t = 'mat', n = 43)

for i in information(6953, t = 'mat', n = 43):
  print(i)

print(information(6953, t = 'mat', n = 43)[0])
"""

def predictions(ID, t):
  P = P_matrix(ID, t, 43)
  description, recommendation = information(ID, t, 43)[:2]
  fig1 = prob_plot(ID, t)
  fig2 = predict_sales(ID, t)

  if t == 'cli':
    valor_cliente = information(ID, t, 43)[2]

    print('--------------------------------------------------------------------Predictions--------------------------------------------------------------------------------------')

    print(f'\nFor client with ID = {ID} the following information was obtained: \n {description}')
    fig1.show()
    print('-----------------------------------------------------------------------------------------------------------------------------------------------------------------------')
    print(f'\nRecommendations: {recommendation}')
    fig2.show()
    print('-----------------------------------------------------------------------------------------------------------------------------------------------------------------------')
    print(f'\nClient Value: {valor_cliente}')
    print('-----------------------------------------------------------------------------------------------------------------------------------------------------------------------')

  else:

    print('--------------------------------------------------------------------Predicciones--------------------------------------------------------------------------------------')

    print(f'\nFor material with ID = {ID} the following information was obtained: \n {description}')
    fig1.show()
    print('-----------------------------------------------------------------------------------------------------------------------------------------------------------------------')
    fig2.show()
    print('-----------------------------------------------------------------------------------------------------------------------------------------------------------------------')
    print(f'\nRecommendation: {recommendation}')
    print('-----------------------------------------------------------------------------------------------------------------------------------------------------------------------')

#predictions(614, t = 'mat')

#predictions(305, t = 'cli')

#predictions(3440, t = 'cli')

#predictions(7271, t = 'mat')

def prod_bought(ID):
  materiales = df[df['id_cliente'] == ID]['id_material']
  return len(set(materiales))

def buyers(ID):
  clientes = df[df['id_material'] == ID]['id_cliente']
  return len(set(clientes))

def top_prod(ID):
    productos = df[df['id_cliente'] == ID].groupby('id_material').size()
    
    top_5_productos = productos.sort_values(ascending=False).head(5)
    
    return top_5_productos

def top_buyers(ID):
    # Filtrar por cliente y agrupar por producto para contar las ventas
    compradores = df[df['id_material'] == ID].groupby('id_cliente').size()
    
    # Ordenar por ventas y obtener el top 5
    top_5_compradores = compradores.sort_values(ascending=False).head(5)
    
    return top_5_compradores

def plot_top(ID, t):
  # Obtener los 5 productos más comprados
  if t == 'cli':

    top_5_productos = top_prod(ID)
    
    # Crear la figura y los ejes
    fig, ax = plt.subplots(figsize=(10, 6))
    
    # Crear el bar plot en el eje
    top_5_productos.plot(kind='bar', color='skyblue', ax=ax)
    
    # Agregar etiquetas y título
    ax.set_title(f'Top 5 products for client {ID}')
    ax.set_xlabel('Prod')
    ax.set_ylabel('Currency Bought')

  else: 
    top_5 = top_buyers(ID)
    
    # Crear la figura y los ejes
    fig, ax = plt.subplots(figsize=(10, 6))
    
    # Crear el bar plot en el eje
    top_5.plot(kind='bar', color='skyblue', ax=ax)
    
    # Agregar etiquetas y título
    ax.set_title(f'Top 5 buyers of {ID}')
    ax.set_xlabel('Client')
    ax.set_ylabel('Currency Sold')
    
    # Retornar la figura
  return fig
